## **单例模式基本信息**
单例是一种创建性设计模式,让你能够保证一个类只有一个实例, 并提供一个访问实例的全局节点


## **适用应用场景**
* 如果程序中的某个类对于所有客户端只有一个可用的实例, 可以使用单例模式
* 如果你需要更加严格的控制全局变量,可以使用单例

## **实现方法**
1.在类中添加一个私有静态成员变量用于保存单例实例  
2.声明一个公有静态构建方法用于获取单例实例  
3.在静态方法中实现延迟初始化(懒汉方式)  
4.将类的构造函数设为私有,类的静态方法仍能调用构造函数,但是其他对象不能调用  
5.检查代码,将对单例的构造函数的调用替换为对其静态构建方法的调用  

## **优缺点**
### 缺点
1.违反了单一职责原则,该模式同时解决了两个问题  
2.单例模式可能掩盖了不良设计  
3.单例模式在多线程环境下需要进行特殊处理,避免多个线程多次创建单例对象
4.单例的客户端代码单元测试可能比较困难  
### 优点
1.仅在首次请求单例对象时对其进行初始化  
2.你可以保证一个类只有一个实例  
3.获得了一个指向该实例的全局访问节点

## 单例的实现
### 饿汉式
**在类加载期间就已经初始化好,缺点是不支持延迟加载的场景**  
### 懒汉式
**支持延迟加载,但是会导致频繁加锁释放锁,以及并发度低等问题,频繁的调用会产生性能瓶颈**
### 双重检测 
**双重检测双重检测实现方式既支持延迟加载、又支持高并发的单例实现方式。只要 instance 被创建之后，再调用 getInstance() 函数都不会进入到加锁逻辑中。所以，这种实现方式解决了懒汉式并发度低的问题**

## 单例存在问题
1.对OOP特性的支持不友好  
**OPP的四大特性是封装、继承、多态、抽象,单例类使用继承、多态实现起来会很奇怪,导致代码的可读性变差**  
2.会隐藏类之间的依赖关系  
**但是，单例类不需要显示创建、不需要依赖参数传递，在函数中直接调用就可以了。如果代码比较复杂，这种调用关系就会非常隐蔽。在阅读代码的时候，我们就需要仔细查看每个函数的代码实现，才能知道这个类到底依赖了哪些单例类**
3.对代码的拓展性不友好  
4.对代码的可测试性不友好  
5.不支持有参数的构造函数  